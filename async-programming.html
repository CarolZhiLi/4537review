<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Async Programming</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .content-page {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .content-title {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .section-title {
            color: #667eea;
            font-size: 1.8em;
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .subsection-title {
            color: #2c3e50;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
            font-weight: 600;
        }
        
        .code-example {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            overflow-x: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }
        
        .question {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .answer {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        
        .highlight {
            background: #f39c12;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            margin-bottom: 30px;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .back-button::before {
            content: "← ";
            margin-right: 8px;
        }
        
        @media (max-width: 768px) {
            .content-page {
                padding: 20px;
            }
            
            .content-title {
                font-size: 2em;
            }
            
            .section {
                padding: 20px;
                margin-bottom: 30px;
            }
            
            .section-title {
                font-size: 1.5em;
            }
            
            .code-example {
                padding: 15px;
                font-size: 0.9em;
            }
        }
        
        @media (max-width: 480px) {
            .content-page {
                padding: 15px;
            }
            
            .content-title {
                font-size: 1.6em;
            }
            
            .section {
                padding: 15px;
            }
            
            .code-example {
                padding: 12px;
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">Back to Quiz Collection</a>
        
        <div class="content-page">
            <h1 class="content-title">⚡ JavaScript Asynchronous Programming</h1>
            
            <div class="section">
                <h2 class="section-title">1. Functions Returning Objects (The Factory Pattern)</h2>
                <p>A factory function is any function that is not a constructor but returns a new object. This is a powerful pattern for creating and configuring objects.</p>
                
                <div class="code-example">function math() {
  return {
    add: function(x, y) {
      return x + y;
    },
    multiply: function(x, y) {
      return x * y;
    }
  };
}</div>
                
                <div class="question">
                    <strong>Q: What does this function return?</strong>
                </div>
                <div class="answer">
                    <strong>A:</strong> It returns an <code>object</code> that contains two methods: <code>add</code> and <code>multiply</code>.
                </div>
                
                <div class="question">
                    <strong>Q: How would you use it to add two numbers?</strong>
                </div>
                <div class="answer">
                    <strong>A:</strong> You first call <code>math()</code> to get the object, then call the <code>.add()</code> method on that object.
                </div>
                
                <div class="code-example">// Call the factory, then the method on the returned object.
const result = math().add(5, 10); // result is 15
console.log(result);

// Alternatively, store the object in a variable for reuse.
const calculator = math();
const sum = calculator.add(2, 3);       // sum is 5
const product = calculator.multiply(4, 5); // product is 20</div>
            </div>
            
            <div class="section">
                <h2 class="section-title">2. Why Asynchronous Operations are Complicated</h2>
                <p>Synchronous code runs top-to-bottom, blocking execution until a task is complete. Asynchronous code starts a task (e.g., a network request) and moves on immediately, running other code. The result of the async task arrives later.</p>
                
                <p>This is complicated because it breaks the linear flow of code and requires special patterns to manage.</p>
                
                <div class="subsection-title">Analogy: Ordering Coffee</div>
                <ul>
                    <li><strong>Synchronous:</strong> A vending machine. You wait, blocked, until you get your coffee.</li>
                    <li><strong>Asynchronous:</strong> A barista. You order, get a buzzer (a "Promise"), and are free to do other things until the buzzer goes off (the Promise resolves).</li>
                </ul>
            </div>
            
            <div class="section">
                <h2 class="section-title">3. The Evolution of Handling Asynchronicity</h2>
                
                <h3 class="subsection-title">3.1 The Old Way: Callbacks & Callback Hell</h3>
                <p>A callback is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.</p>
                
                <div class="subsection-title">Example: Sequential Asynchronous Tasks</div>
                <p>To guarantee that <code>f2</code> runs after <code>f1</code>, you must nest the call to <code>f2</code> inside the callback of <code>f1</code>.</p>
                
                <div class="code-example">function async(callback) {
  setTimeout(callback, Math.random() * 1000);
}

// Nesting ensures f1 -> f2 -> f3
async(() => {
  console.log(1);
  // Start the next operation only after the first is done
  async(() => {
    console.log(2);
    // And the next...
    async(() => {
      console.log(3);
    });
  });
});</div>
                
                <p>This deep nesting is known as <strong>"Callback Hell"</strong> or the "Pyramid of Doom" and is very difficult to read and maintain.</p>
                
                <h3 class="subsection-title">3.2 A Better Way: Promises</h3>
                <p>A <code>Promise</code> is an object representing the eventual completion (or failure) of an asynchronous operation. It acts as a placeholder for a future value.</p>
                
                <h4>The Golden Rule of Promises: One-Time Settlement</h4>
                <p>A promise can only be settled (fulfilled or rejected) <strong>once</strong>. After it's settled, its state is locked and will never change. Any further attempts to call <code>resolve()</code> or <code>reject()</code> are ignored.</p>
                
                <div class="subsection-title">Example: <code>setInterval</code> and a Promise</div>
                <p>This code attempts to resolve a promise every 100ms.</p>
                
                <div class="code-example">let promise = new Promise((res) => {
  setInterval(() => {
    res("Hi");
  }, 100);
});

promise.then((mes) => { console.log(mes) });</div>
                
                <div class="question">
                    <strong>Q: How many times will "Hi" be logged?</strong>
                </div>
                <div class="answer">
                    <strong>A: Only once.</strong> The first time <code>res("Hi")</code> is called after 100ms, the promise becomes fulfilled. All subsequent calls to <code>res()</code> from the interval are ignored.
                </div>
                
                <h3 class="subsection-title">3.3 The Modern Way: <code>async/await</code></h3>
                <p><code>async/await</code> is syntactic sugar built on top of Promises. It lets you write asynchronous code that looks and behaves like synchronous code, making it much easier to read and reason about.</p>
                
                <div class="code-example">// A function that returns a promise
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function runInOrder() {
  console.log('Starting...');
  
  await delay(1000); // Pauses execution for 1 sec without blocking
  console.log(1);
  
  await delay(1000); // Pauses again
  console.log(2);
  
  await delay(1000); // And again
  console.log(3);
  
  console.log('Finished!');
}

runInOrder();</div>
            </div>
            
            <div class="section">
                <h2 class="section-title">4. Deep Dive: The Event Loop</h2>
                
                <h3 class="subsection-title">4.1 Microtasks vs. Macrotasks</h3>
                <p>The Event Loop manages how asynchronous code is executed. It uses two primary queues with different priorities:</p>
                
                <ul>
                    <li><strong>Microtask Queue (Higher Priority):</strong> Holds callbacks from Promises (<code>.then</code>, <code>.catch</code>). The event loop will run <strong>ALL</strong> tasks in this queue until it's empty before moving on.</li>
                    <li><strong>Macrotask Queue (Lower Priority):</strong> Holds callbacks from <code>setTimeout</code>, <code>setInterval</code>, I/O, user events. The event loop will only pick <strong>ONE</strong> task from this queue per "tick".</li>
                </ul>
                
                <div class="subsection-title">The Order of Operations:</div>
                <ol>
                    <li>Run all synchronous code on the Call Stack.</li>
                    <li>Process the <strong>entire</strong> Microtask Queue.</li>
                    <li>Process <strong>one</strong> task from the Macrotask Queue.</li>
                    <li>Repeat from step 2.</li>
                </ol>
                
                <h3 class="subsection-title">4.2 Event Loop Code Puzzles</h3>
                
                <h4>Puzzle 1</h4>
                <div class="code-example">Promise.resolve().then(() => console.log(1));
console.log(2);</div>
                <div class="answer">
                    <strong>Output:</strong> <code>2</code>, then <code>1</code><br>
                    <strong>Reasoning:</strong> <code>console.log(2)</code> is synchronous and runs first. The promise's <code>.then()</code> is a microtask and runs only after the synchronous script is finished.
                </div>
                
                <h4>Puzzle 2</h4>
                <div class="code-example">const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

wait(0).then(() => console.log(2));
Promise.resolve().then(() => console.log(3)).then(() => console.log(1));
console.log(4);</div>
                <div class="answer">
                    <strong>Output:</strong> <code>4</code>, <code>3</code>, <code>1</code>, <code>2</code><br>
                    <strong>Reasoning:</strong><br>
                    1. <code>console.log(4)</code> is synchronous.<br>
                    2. <code>console.log(3)</code> is the first microtask. Its completion schedules <code>console.log(1)</code> as another microtask.<br>
                    3. The microtask queue must be fully cleared, so <code>console.log(1)</code> runs next.<br>
                    4. Finally, the <code>setTimeout(resolve, 0)</code> callback (a macrotask) runs. This resolves the <code>wait</code> promise, which in turn schedules <code>console.log(2)</code> as a microtask for the <em>next</em> tick of the event loop.
                </div>
            </div>
            
            <div class="section">
                <h2 class="section-title">5. Practical Application: Sequential AJAX Calls</h2>
                <p><strong>Goal:</strong> Get data from Server A, and only then use that data to send an update to Server B.</p>
                
                <h3 class="subsection-title">5.1 The Callback Approach</h3>
                <p>This uses the original <code>XMLHttpRequest</code> object and nests the second call inside the success handler of the first.</p>
                
                <div class="code-example">function getAndUpdateScore() {
  const xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState === 4 && this.status === 200) {
      // Step 1: First request succeeded.
      const score = parseInt(this.responseText);
      
      // Step 2: Now, start the second request.
      const xhttp2 = new XMLHttpRequest();
      xhttp2.onreadystatechange = function() {
        if (this.readyState === 4 && this.status === 200) {
          console.log('Score updated successfully!');
        }
      };
      xhttp2.open("PATCH", "http://serverB.com/updatescore", true);
      xhttp2.send(`score=${score}`);
    }
  };
  xhttp.open("GET", "http://serverA.com/getscore", true);
  xhttp.send();
}</div>
                
                <h3 class="subsection-title">5.2 The Modern <code>async/await</code> Approach</h3>
                <p>This uses the modern, promise-based <code>fetch</code> API for cleaner, flatter code.</p>
                
                <div class="code-example">async function getAndUpdateScoreModern() {
  try {
    // Step 1: Get the score from Server A
    const responseA = await fetch("http://serverA.com/getscore");
    const scoreData = await responseA.json(); // Assuming JSON response
    
    // Step 2: Update the score on Server B
    const responseB = await fetch("http://serverB.com/updatescore", {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ score: scoreData.score })
    });
    
    const result = await responseB.text();
    console.log(result);
    
  } catch (error) {
    console.error("Failed to get or update score:", error);
  }
}</div>
            </div>
            
            <div class="section">
                <h2 class="section-title">6. Practical Application: Measuring AJAX Request Timings</h2>
                <p>We can use <code>performance.now()</code> for high-resolution timestamps to measure different phases of a request.</p>
                
                <h3 class="subsection-title">Q1: Total Round-trip Time</h3>
                <p>Measure from just before <code>.send()</code> to when <code>readyState</code> is 4 (DONE).</p>
                
                <div class="code-example">function measureTotalRequestTime() {
  const xhttp = new XMLHttpRequest();
  let startTime;

  xhttp.onreadystatechange = function() {
    if (this.readyState === 4) { // DONE
      const totalTime = performance.now() - startTime;
      console.log(`Total request time: ${totalTime.toFixed(2)} ms`);
    }
  };

  xhttp.open("GET", "https://api.github.com/users/octocat", true);
  startTime = performance.now();
  xhttp.send();
}</div>
                
                <h3 class="subsection-title">Q2: Body Download Time</h3>
                <p>Measure from when <code>readyState</code> is 2 (HEADERS_RECEIVED) to when <code>readyState</code> is 4 (DONE).</p>
                
                <div class="code-example">function measureBodyDownloadTime() {
  const xhttp = new XMLHttpRequest();
  let headerTime;

  xhttp.onreadystatechange = function() {
    if (this.readyState === 2) { // HEADERS_RECEIVED
      headerTime = performance.now();
    }
    if (this.readyState === 4) { // DONE
      const downloadTime = performance.now() - headerTime;
      console.log(`Body download time: ${downloadTime.toFixed(2)} ms`);
    }
  };

  xhttp.open("GET", "https://api.github.com/users/octocat", true);
  xhttp.send();
}</div>
            </div>
        </div>
    </div>
    <script src="toggle-answers.js" defer></script>
</body>
</html>
